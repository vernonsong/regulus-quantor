# -*- coding: utf-8 -*-
# 欲买桂花同载酒，
# 终不似、少年游。
# Copyright (c) VernonSong. All rights reserved.
# ==============================================================================
import numpy as np
import pandas as pd
import requests


# 初始化函数
def initialize(context):
    set_slippage(FixedSlippage(0.02),
                 type='stock')  # 为股票设定滑点为百分比滑点     set_slippage(PriceRelatedSlippage(0.00246),type='stock')
    set_slippage(FixedSlippage(0.002),
                 type='fund')  # 为股票设定滑点为百分比滑点     set_slippage(PriceRelatedSlippage(0.00246),type='stock')

    # 设置交易成本
    set_order_cost(
        OrderCost(open_tax=0.0, close_tax=0.0, open_commission=0.0003, close_commission=0.0003, min_commission=5),
        type='fund')
    set_benchmark('000300.XSHG')
    set_option('use_real_price', True)
    set_option("avoid_future_data", True)
    log.set_level('system', 'error')
    g.etf_pool = ['510050.XSHG', '512480.XSHG', '513050.XSHG', '511010.XSHG', '159929.XSHE', '512070.XSHG',
                  '512400.XSHG', '513100.XSHG', '510880.XSHG', '518800.XSHG', '510150.XSHG', '513030.XSHG',
                  '513000.XSHG']
    g.m_days = 25
    run_daily(trade, '09:35')


def get_rank(etf_pool):
    score_list = []
    score_dict = {}
    for etf in etf_pool:
        df = attribute_history(etf, g.m_days, '1d', ['close'])
        y = df['log'] = np.log(df.close)
        x = df['num'] = np.arange(df.log.size)
        slope, intercept = np.polyfit(x, y, 1)
        annualized_returns = math.pow(math.exp(slope), 250) - 1
        r_squared = 1 - (sum((y - (slope * x + intercept)) ** 2) / ((len(y) - 1) * np.var(y, ddof=1)))
        score = annualized_returns * r_squared
        score_list.append(score)
        score_dict[etf] = score
    df = pd.DataFrame(index=etf_pool, data={'score': score_list})
    df = df.sort_values(by='score', ascending=False)
    print(df)
    df = df[(df['score'] > -0.5)]

    rank_list = list(df.index)

    url = "https://vernonsong.cpolar.top/regulus/strategy/score/save"
    headers = {"Content-Type": "application/json"}
    try:
        response = requests.post(
            url,
            json=score_dict,  # 按行转换为JSON数组
            headers=headers
        )
        response.raise_for_status()
        print(f"数据传输成功!")
    except requests.exceptions.RequestException as e:
        print(f"请求失败: {e}")



    return rank_list


# 交易
def trade(context):
    target_num = 1
    etf_pool = get_trend_length(g.etf_pool, 5)
    target_list = get_rank(etf_pool)[:target_num]

    # 卖出
    hold_list = list(context.portfolio.positions)
    for etf in hold_list:
        if etf not in target_list:
            order_target_value(etf, 0)
    # 买入
    hold_list = list(context.portfolio.positions)
    if len(hold_list) < target_num:
        value = context.portfolio.available_cash / (target_num - len(hold_list))
        for etf in target_list:
            if context.portfolio.positions[etf].total_amount == 0:
                order_target_value(etf, value)
    hold_list = list(context.portfolio.positions)
    if hold_list:
        print(f'- 持有:  {mingcheng(hold_list[0])}, {hold_list[0]}')


# ####################################################################
# 本人添加程序

def calculate_ma(data, window):
    return data.rolling(window=window).mean()


def count_days_above(data, short_window, long_window):
    # 计算短期和长期均线
    short_ma = calculate_ma(data, short_window)
    long_ma = calculate_ma(data, long_window)

    # 初始化计数器
    count = 0
    total_days = 0

    for i in range(long_window, len(data)):
        if short_ma[i] > long_ma[i]:
            if i == long_window or short_ma[i - 1] <= long_ma[i - 1]:
                # 如果是突破点，则重置计数器
                count = 0
            count += 1
        else:
            # 如果短期均线跌落到长期均线下方，则结束计数
            count = 0

        if count > 0:
            total_days += count

    return total_days / (len(data) - long_window)


# 假设df是一个包含所有股票历史数据的DataFrame，
def get_trend_length(etf_pool, limit):
    df = history(3500, unit='1d', field='close', security_list=etf_pool, df=True, skip_paused=True, fq='pre')

    stocks_data = {stock: df[stock] for stock in df.columns}

    # 短期和长期均线窗口
    short_window = 10
    long_window = 30

    # 统计每只股票的数据
    results = {stock: count_days_above(data, short_window, long_window) for stock, data in stocks_data.items()}
    print(results)
    results = {stock: results[stock] for stock in results if results[stock] > limit}
    # 按平均天数降序排序
    # sorted_results = sorted(results.items(), key=lambda x: x[1], reverse=True)
    return list(results.keys())  # sorted_results


def mingcheng(stock):
    try:
        return get_security_info(stock).display_name
    except:
        return "还未上市"
